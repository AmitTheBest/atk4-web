<?$Content?>

<h1>Defining and using Relational Models</h1>

<p>The syntax of defining Relational Models is very similar to a regular models. There are however few differences:
<ul>
  <li>You should inherit from Model_Table</li>
  <li>You do not need to use setSource()</li>
  <li>You must specify $table property for each model, which is primary table</li>
</ul>
In addition, you have more methods to use and define fields.</p>
<h2>Defining and Traversing References between Models</h2>
<?Code?>
class Model_Author extends Model_Table {
  public $table='author';
  function init(){
    parent::init();
    $this->hasMany('Book');
    $this->hasOne('Country');

    // field definitions
  }
}
<?/?>
<p>A further use of the model can use function rel() to traverse towards other records. You must, however, load author record before traversing.</p>
<?Code?>
$author = $this->add('Model_Author');
$author->load($id);
$c_code = $author->ref('country_id')->get('Code');

$this->add('Grid')->setModel($author->ref('Book'));
<?/?>
<p>When traversing relations defined as "hasOne" the record of related model is automatically loaded. You should use the name of the field as an argument to ref() function. </p>
<p>When traversing relations defined as hasMany() the returned model will not be preloaded with any records. It will however have a condition added to make sure any new records you are going to add with that model will belong to author identified by $id.</p>

<h2>Building model from multiple tables</h2>
<p>Let's assume that to store additional information about the author a new table "author_details" is created. This table contains "author_id". While in theory one author may have multiple records in author_details our logic dictates that it's one-on-one relationship. "author_id" is also defined as a primary field.</p>

<p>While we could have used references, it wouldn't let us join 2 tables seamlessly. To help out Model_Table has a join() method.</p>
<?Code?>
  // init of Model_Author
  $details = $this->join('author_details.author_id');

  $details->addField('bio');
  $details->addField('note')->as('details_note');
<?/?>


<h3>Default Fields</h3>
<p>Agile Toolkit uses some assumptions about the relations between fields. Table 'author' will have 'country_id' which is constructed by looking into 'Country' model's $table property and appending '_id'. That field is then loaded based on the "id" field of Author. If your id field is called differently, you can change id through a property "$id_field".</p>

<p>Sometimes you need to use a different field name when referencing. Then you need to use 2nd argument to "hasOne('Country','birth_country_id')".</p>

<h2>Using non-ID fields for loading</h2>
<p>There are different ways how you can load model. For example calling load() without arguments will load the first possible match from the available data.</p>

<h3>loadBy($field,[$cond],$value)</h3>
<p>This function will load model through a non-ID field. The second argument is optional and if defined it can specify the relationship, such as:</p>
<?Code?>
$model->loadBy('age','>','25');
<?/?>
<p>You may also use a DSQL expression as a first argument and omit condition and values alltogether.</p>
<?Code?>
$model->loadBy($model->dsql->expr('expire_dts>now()'));
<?/?>

<h3>getBy($field,[$cond],$value)</h3>
<p>This similar syntax will return array of hashes produced the model's select.</p>

<?Code?>
$data = $model->getBy($model->dsql->expr('expire_dts>now()'));
echo json_encode($data);
<?/?>

<p>calling getBy() will not affect the currently loaded record.</p>

<h3>getRows(array)</h3>
<p>This is similar to getBy but it allows to define which fields you are willing to retrieve:</p>

<?Code?>
$data = $model->getRows(array('id','name'))
echo json_encode($data);
<?/?>

<h2>Iterating Through Entities</h2>
<p>Model supports agregation, which means you can use it like this:</p>

 
<?Code?>
foreach($this->add('Model_Book') as $book){
    $book['sale']++;
    $book->save();
}
<?/?>

<h2>Debugging</h2>
<p>Model has a method debug() which will turn on debugging mode on the queries it produces and executes. This relies on <a href="<page?>doc/dsql/how<?/?>">DSQL debug()</a>.

<p>When iterating, the $book will always refer to the same model, but it will have appropriate record loaded.</p>

<h2>Deleting Entities</h2>
<p>Model attempts to prevent accidental data loss and therefore $model->delete() will only remove data from the database if you either specify "id" or have a record loaded.</p>


<?$Next?>
