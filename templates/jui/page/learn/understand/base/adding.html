<?$Content?>

<div class="g-row">
  <div class="g-12">

<h1>Adding objects in Agile Toolkit</h1>

<p>Adding is one of the most important concepts an Agile Toolkit. When you need to create any object, instead of using "new" operator you add instance of an object to any other object. Here is the simplest form of adding:
</p>
<?Code?>
$form = $page->add('Form');
<?/?>
<p>Agile Toolkit requires that you initialize objects before calling methods. There are no static methods in Agile Toolkit classes. When add() is used, in addition to creating new object instance.</p>

<p>All objects of Agile Toolkit live in a Runtime Tree. It's similar to "DOM" of the browser, where top-most object is your application (which I will call "api") and it contains many other objects responsible for different things. Each object have an "owner" â€” reference to an object who created them. Owner of the $form would be $page. Typically owner of a $page is application. </p>
<p>All objects are also given unique identifier: "name". Each objects have their own name and no two objects would have a same name.</p>

<p>Calling add() returns object, so you can call it's method instantly without even assigning it to a variable:</p>

<?Example?>
$page->add('Button')->set('Click me');
<?/?>

<h2>init() method</h2>

<p>When new object is created, normally constructor is called. Agile Toolkit objects never use default PHP constructors. Instead all objects of Agile Toolkit have init() method. This method is called after Agile Toolkit initializes new object and links it to "owner" and "api". View objects will also have their template loaded and parsed by the time init() is executed.</p>

<p>init() method can be used to add more objects or modify properties of your custom object. For example, if I want to create new class for a button, I would use the following code:</p>

<?Code?>
class MyButton extends Button {
    function init(){
        parent::init();
        $this->set('Click Me');
    }
}
<?/?>

<p>Now I can use my new object instead of adding a standard button and changing it's label:</p>
<?Code?>
$page->add('MyButton');
<?/?>

<p>Using this approach you can enhance ANY class of Agile Toolkit. Here is another example of a form which will be initialized with fields:</p>

<?Code?>
class Form_ContactForm extends Form {
    function init(){
        parent::init();

        $this->add('Disclaimer');

        $this->addField('line','name');
        $this->addField('line','surname');
        $this->addSubmit('Send');
    }
}
<?/?>
<h2>Other forms of adding</h2>
<p>Some objects introduce wrappers for adding objects. This is done for convenience as they would usually automatically decide which class should be used. The ContactForm example you saw before uses addField() and addSubmit(). Both functions rely on add() but with some extra logic. Most functions starting with "add" do this, however. there are some functions which do not use this convention: js(), dsql() and exception() create and return new object, but $grid-&gt;addColumn() does not create new object dispite the name. </p>

<h2>More Examples</h2>
<?Code?>
$admin=$this->add('Model_User')->addCondition('admin',true);
<?/?>
<p>
Adds model to the current object. add() returns an instance of a new object, making it possible for you to chain-call methods of the newly added object.
</p>
<?Code?>
$menu=$this->api->add('Menu',null,'Menu');
<?/?>
<p>
Adds menu inside api, and use a template spot 'Menu' inside the api's template for output.
</p>

<h2>The second argument</h2>
<p>When we are adding objects, the second argument can be used to specify the short_name or properties of the object. When left as "null" object will produce unique short_name on it's own, based on class name. Short name is used to link "owner" with it's object through "elements" array.</p>

<?Code?>
$page->add('Form','my_form');

if($page->hasElement('my_form')){
  // has form
}

$page->getElement('my_form')->owner;  // refers back to $page
<?/?>

<p>If you specify array as a second argument to add() it will be used as default set of properties for your object. You can access theese properties from init() method and it's a great way to pass arguments to it. This practice is popular in some frameworks such as "Yii" but in Agile Toolkit it is very rarely used.</p>

<?Code?>
$model->add('MyObject',array('foo'=>'bar'));
echo $model->foo;
<?/?>

<h2>Planning your object functionality properly</h2>
<p>
Your init() method must be very short, fast and simple. The goal of init() method is to initialize sub-objects and properties. Subsequental calls to methods can be used to further modify the state of the object. If you are creating new "View" then as much work as possible should be delayed until rendering of the object. This is due to a fact that sometimes objects may be initialized and rendered selectively.
</p>

<h2>Working with existing objects</h2>
<p><b>$this->hasElement($short_name)</b> return child object if found, or false if not found.</p>
<p><b>$this->getElement($short_name)</b> similar to hasElement() but will produce an exception if not found. Use this when chaining.</p>
<p><b>$this->destroy()</b> remove the current object from its owner. For a view, this will remove it from rendered page.</p>
<p><b>$this->rename($new_short_name)</b> can rename an object, but might not work with some objects.</p>
<p><b>$this->newInstance()</b> will add a copy of the object and add into the same owner. Unlike cloning, object state is not copied.</p>

<p>Properties: <b>$this->name</b> name unique to the system. <b>$this->short_name</b> is a unique amongst owners children. <b>$this->template</b> reference to the SMlite template for the current view. <b>$this->owner</b> reference to the object whose add() was used (the parent). <b>$this->api</b> refers to the API class of the parent object.</p>

</div></div>
<?$Next?>
