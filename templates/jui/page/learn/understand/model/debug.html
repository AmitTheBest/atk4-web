<?$Content?>

<h1>Debugging Models</h1>
<p>An important thing about models you should understand, is that models on their own are here to serve 4 purposes:</p>
<ul>
  <li>Produce dynamic SQL objects</li>
  <li>Load, hold and save a single record of data</li>
  <li>Contain meta-information for other views</li>
  <li>Perform business operations</li>
</ul>
<p>Some actions are more likely to go wrong, usually because of incorrectly defined fields.
</p>

<h3>Debugging produced SQL statement</h3>
<p>You can switch on debug mode for any model by calling:
<?Code?>
$model->debug();
<?/?>

<p>This will output queries as they are being generated by the underlying Dynamic SQL object(s). This method is good to see how dynamic SQL queries are being produced, and how data is being loaded, saved or otherwise accessed.</p>

<p>If your query seems to be overly complicated and you want to isolate individual fields, you can use setActualFields();</p>
<?Code?>
$model->debug();
$model->setActualFields(array('calculated_field_1'));
$model->load(123);
<?/?>

<h3>Get current row data from model</h3>
<p>You can see what's inside your model by calling var_dump($model->get()). This will output contents of the currently loaded record.</p>

<h3>Transaction support</h3>
<p>Agile Toolkit attempt to rely on SQL transactions. When model is being save()d, it will attempt to re-load record afterwards. If the load fails due to conditions, the whole transaction is rolled back undoing save.</p>

<p>Often you can also use transactions operations to improve your code</p>

<?Code?>
class Model_Book extends Model_Table {
    
    // Skipped

    function addMultipleBooks($data){
        $this->_dsql()->owner->beginTransaction();

        foreach($data as $row){
            $this->unloadData();
            $this->set($row);
            $this->save();
        }

        $this->_dsql()->owner->commit();
    }
}
<?/?>

<p>If error happens during inserts, an exception will bubble up through the call-stack and data will not be committed.</p>

<h3>Adding more information to exceptions</h3>
<p>In Agile Toolkit error reporting is implemented using Exceptions. To improve reporting you can intercept the exception add more information to it.</p>
<?Code?>
    function addMultipleBooks($data){
        $this->_dsql()->owner->beginTransaction();
        try { 
            foreach($data as $row){
                $this->unloadData();
                $this->set($row);
                $this->save();
            }
        }catch(BasicException $e){
            throw $e->addMoreInfo('record_count',count(data));
        }
        $this->_dsql()->owner->commit();
    }
<?/?>
<p>Catching an exception will allow you to manipulate it - such as calling addMoreInfo(). This is chain-able method and therefor you can "throw" value returned by it.</p>

<h3>exception() method</h3>
<p>Agile Toolkit defines the exception() method globally. Each model can define which exception class it uses, and the exception() function will return an instance of this class. This also allows for a more flexible syntax in the PHP code: throw $this->exception()->addMoreInfo(..)</p>
<p>You can either redefine this method to add additional information - such as certain data from the model for exceptions which are being generated - or specify a different exception class through the $default_exception property.</p>

<?$Next?>
