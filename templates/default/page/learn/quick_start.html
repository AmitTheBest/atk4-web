<?$Content?>

<div class="atk_doc">
<h1>Quick Start</h1>
<p>
Agile Toolkit is about results. It is about development of Web software. Specifically a dynamic, customizable and flexible Web Interface with a extensive and separated Business Logic. Agile Toolkit gives you, a developer, a faster ride.
</p>
<p>
It's impossible to copy concepts of other general PHP frameworks and make web development faster. That's why Agile Toolkit is different. It's easier to understand, easier to write. It takes care of things and all the components integrate seamlessly.
</p>
<p>
Developing with Agile Toolkit is the following of concepts of Agile Toolkit. If you are uncomfortable with those concepts, we suggest to use general-purpose framework. General purpose frameworks give choices, Agile Toolkit makes choices.
</p>
</div>

<div class="clear"></div>
<div class="hr hr-small"></div>
<div class="g-row">
	<div class="g-6">
		<h3>Choosing Api Class</h3>
		<p>
		The application you are about to develop using Agile Toolkit will require you to define at least one class. That class is called <a href="<?page?>doc/api<?/?>">"Api" class</a> and can be inherited from some of the standard Api classes. For a fully featured Web Application it's recommended that your API class is inherited from ApiFrontend. If you need to create a cron-script or command-line utility you should use ApiCLI component. ApiWeb class can be used if you are willing to integrate Agile Toolkit into other software / framework.
		</p>
		<p>
		Api object is the "only" object which must be manually created. All the other objects are "added" either into Api or into other object. The resulting hierarhy is called "Runtime Tree".
		</p>
		<p>
		Api class does not have require to have any functionality, however it would typically add a number of "Api Controllers" classes. Those would take care of page routing, database connection, authentication and other tasks.
		</p>
		<p>
		ApiFrontend will initialize most of those controllers for you. It will also initialize page routing and will add a proper page.
		</p>
		<h3>Models</h3>
		<p>In Agile Toolkit Model reflects a business entity. "User" is a good example of a model. Models are implemented as classes, therefore you can inherit models from other models. For example "User_Administrator" could be inherited from "User", but would add additional fields and conditions.
		</p><p>
		Models are optional in Agile Toolkit, although we highly recommend you to learn and use them. All the standard views can work with static data, dynamic sql or models. Models contain field definitions, validation rules, relations and additional actions.
		</p>
		<h3>Helper</h3>
		<p>In Agile toolkit helpers are all sorts of other classes which are used but can't be classified in any other way. For example when you add field to model, FieldDefinition helper class will be used. jQuery_Chain is another helper class, which records actions for JavaScript binding. You can use 3rd party library classes and they would be considered "helpers" too.</p>
		
	</div>
	<div class="g-6">
	
		<h3>Pages</h3>
		<p>
		Pages in Agile Toolkit are implemented as ... classes. Api class will automatically determine which page user tried to access and will "add" a proper page into itself. The page would be responsible for the content, which is specific to that page. In other words pages output will not affect header / footer of your HTML.
		</p>
		<p>
		Each page has a name and pages can be nested. For example you can create a page "settings/password". On other hand you can create page "settings" and define "password" as a sub-page. Pages always inherit class "Page" either directly or indirectly. 
		</p>
		<p>
		If your page class cannot be located in page/ directory, the Api will add a generic page using "Page" class and will use static template located in templates/[skin]/page/ 
		</p>
		<h3>Views</h3>
		<p>
		View in Agile Toolkit is also a class. Anything what is producing an output is a View. Because Api and Page also produce output, they are descendants of AbstractView.
		</p>
		<p>
		Any View object will have a template. Views can have a default template or it can be specified or inherited. For example — default template of Api class is "shared.html" — that's where your header/footer is. When you are adding view, you can instruct it to read template from a separate file or clone region from parent's template.
		</p>
		<p>
		Another common property of all Views is called a "spot". That's a location in template of their parent where rendered output of a View is inserted. For instance, shared.html file contains a tag &lt;?$Content?&gt;. This tag is used as a "spot" for pages. Navigation menu is using spot &lt;?Menu?&gt;, which is also found in shared.html. 
		</p>
		<h3>Controllers</h3>
		<p>Controllers are used as a glue in Agile Toolkit. They are also used to modify and enhance behavior of other objects. Controller is implemented as a class. Adding same controller twice into any object will result in only a single controller being added.
		</p>
	</div>
</div>

<h2>Understanding the Structure</h2>
<p>
In Agile Toolkit, everything is implemented as a class. Classes, however, play different roles such as Api, Page, View, Model, Controller and Helper. The only two non-object-oriented components are your templates (which are files with HTML fragments) and database (MySQL).
</p>



<h2>Structured Web Interface</h2>
<p>
First thing you will probably notice, is that while many other generic frameworks approach "page" as a entity to break into model / view / controller, Agile Toolkit implements a much different approach. Agile Toolkit looks at your page recursively. You might have "Accordion" in your page, inside which you may put a Form inside which you will add a button. Each of those 3 would have their own templates. Because templates in Agile Toolkit are universal, you can easily add anything anywhere and it will just work. This ability to break down your interface into component library then using them inside hierarchy is what makes Agile Toolkit an "UI" framework.
</p>
<p>
This clever implementation is delivered to a developer in a simplest possible way:
</p>
<?Code?>
 $accordion = $page->add('Accordion');
<?/?>
<p>
A regular developer of web software wouldn't need to worry about what happens behind the scenes. What is important is that you now have a working accordion on your page.
</p>
<div class="continue-block">
<a class="button blue big" href="<?page?>../../adding<?/?>">Continue to "Adding Objects"</a>
</div>
