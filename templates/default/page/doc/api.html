<?$Content?>

<h1>Application and Framework</h1>

<p>Agile Toolkit is a collection of UI Views and practically applicable controllers built on top of a simple and elegant object-oriented framework. While all the other components of Agile Toolkit have a very strict focus, Application and Framework are designed to pull all of the features together and also provide a foundation for all the other code as well as the one you would be producing.</p>

<h2>Overview</h2>
<p><img style="float: right" src="<?template?>images/schemas/api_doc.png<?/?>"/>
  When your user directs his internet browser towards a Agile Toolkit application, all the requests would be directed towards a "catch-all" file normally called "index.php". The only purpose of this file is to load Application class, create a new instance of applicaiton class and execute the main() method. From that point on, Agile Toolkit will process the requset further including necessary files.</p>


  <p>Agile Toolkit does not use any static elements or global variables. The only global variable you use in the "index.php" class is "$api". All additional classes are added into your API, or into other objects inside the API.</p>

  <?MoreInfo?>Use of Multiple APIs
  <p>Did you know that you can use multiple Application classes? It makes sense sometimes when you are builting a test-frameworks or are willing to perform cross-application authentication. Regardless, Application classes are non-conflicting and non-exclusive.</p>

  <p>For this reason, singletons are not used in Agile Toolkit to avoid version conflicts and have full independence between unrelated objects.</p>
  <?/?>


  <p>The fundamental role of the Application is to understand what to do with the request. The logic behind "pages" is the simple concept introduced to new users of Agile Toolkit as default behaviour. In reality any complex logic can be applied on applicaiton levels.</p>

  <p>There are few Application classes included in Agile Toolkit. ApiFrontend is the default to be used for web application, however ApiCLI is the most suitable for command-line tools, non-visual applications or third party integrations. Unless stated otherwise, the rest of this documentation will apply to application based of ApiFrontend.</p>

 <h3>Initialization and Rendering phases of the Application</h3> 
 <p>
  <img src="<?template?>images/ugly_images/apiseq.png<?/?>" style="float: right">
  An API in Agile Toolkit splits the whole execution of the application into 2 parts: Initialization and Rendering. During the initialization phase application established, which objects needs to be created and what configuration have to be used. During rendering, the data is being pulled from the database and the HTML output is produced.</p>


  <p>Agile Toolkit objects never output anything directly. Instead, they insert their output into their parent's template. Only the Application class will send the complete HTML output to the user. If non-HTML response needs to be provided, a responsible object can echo it and stop the execution.</p>

  <h4>Initialization</h4>
  <p>init() method of all the objects is called during the Initialization phase. Objects are requested to add other necessary objects and also associate them with the proper models. All the views are advised not to perform any data querying in the init() method. Agile Framework may need to render only some objects so any CPU or Database intensive functionality must be done during rendering.</p>

  <p>Initialization phase can be instantly terminated by throwing Exception_StopInit()</p>

 <h4>Rendering</h4> 
 <p>Each View added into application or any other view will recive a call to their method recursiveRender(). This method will render all the child views first and then rall render(). Inside this method object can rely on output() method to send chunks of HTML to be placed in the owner-view.</p>

 <p>The default behaviour of render() is to simply render template associated with a view by calling $this->output($this->template->render()).</p> 

 <a href="<?page?>doc/view<?/?>">Further information about Views, HTML, Rendering and SMLite</a>

<h4>Applicaiton Hooks</h4>
<p>Between Initialization and Rendering there are multiple hooks objects can take advantage of to postpone some of the initialization steps. For example the forms will attempt to check for the submitted data through 'pre-exec' and 'submitted' hook. Here is the sequence of the hooks in ApiFrontend()
  <ul>
    <li>init()</li>
    <li>post-init</li>
    <li>pre-exec</li>
    <li>submitted (if POST data is supplied)</li>
    <li>post-submit</li>
    <li>cut-output (called if any view is refreshed through AJAX)</li>
    <li>pre-render-output (called otherwise)</li>
    <li>post-render-output</li>
  </ul>
  There are also other hooks, but those would be called multiple times or depending on further conditions.
</p>


<p>The Application in Agile Toolkit also has a template which is called "shared.html" by default. Finally the rendering of the Agile Toolkit can be interrupted by throwing Exception_StopRender. Similarly to StopInit, no error will be produced and the exception is only used to bail-out from the depths of method calls. It is used when the cut_object argument is present.</p>

<h3>Realms</h3>
<p>When the API class is initialized it expects only one argument: the "realm". A Realm must be unique to an application or even to an installation. The realm becomes the "name" of your $api, and it will also be used in all unique IDs (cookies, DOM id's, session variables).</p>

<p>Through combining the concept of multiple APIs with proper realms, you can implement some unique features - such as a "Login As User" feature, by actually using the frontend API and calling the "login" method of its auth object.</p>


<h3>Cutting Output</h3>
<p>In some situations a full rendering of the page is not required. For example when a view is reloading itself using an AJAX request, only the rendering of particular object is necessary. All the views will watch for argument "cut_object" and compare it with either "name" or "short_name" property. If it matches, the object output will be generated and then further rendering will be terminated by throwing Exception_StopRender. Application class will intercept this exception and output supplied HTML and not the rest.</p>

<h4>Other arguments for cutting</h4>
<p>Page objects will watch for the argument "cut_page". If it is set, the page will output only it's content, excluding the content of shared.html.</p>

<h3>Layouts</h3>
<p>A Layout is a feature implemented in ApiFrotnend. It allows for a certain 
  methods to be executed if the Application's template contains an respective tag.</p> 

<p>The menu could be implemented as a Layout, so that layout_Menu would only be called if Menu tag is present in the template. When you want to implement a printing function on your pages, you will supply a different template for Application class without the menu tag (optimized for print). The layout method will not be called.</p>

<p>The only Layout which is defined initially is called "Content". This tag "Content" is then populated with the output from a appropriate page inside method layout_Content. The routing logic is explained further under the Routing section.</p>

<h4>Adding a New Layout</h4>
<p>You will need to call addLayout('Menu') inside the init() of your application. After init() application will automatically call it's own initLayout() method which will then look for the Menu tag in the template and if &lt;?Menu?&gt; is found, call layout_Menu().</p>


<div class="clear"></div>


<div class="g-row" id="doc-ref">
  <div class="g-6">

    <div class="g-row">
      <div class="g-2">
      </div>
      <div class="g-4">
        <h3>Application (api) Class</h3>
        <p>Application class delegates all of the functionality of your applicaiton to Pages, Views, Controllers and Models.
        </p>
      </div>
    </div>

    <div class="ref-item box blue-noised">
      <b>Table of Contents:</b>
      <?$toc?>
    </div>

    <?List?>
    <div class="ref-item box blue-noised">
      <b>Other Resources, Blog posts:</b>
      <div class="details white">
        <div><a href="<?page?>learn/understand/api<?/?>">Introduction to Application Classes</a></div>
        <div><a href="http://agiletoolkit.org/blog/integrating-agile-toolkit-with-wordpress/">Integrating Agile Toolkit with WordPress</a></div>
        <div><a href="http://agiletoolkit.org/blog/wp-admin/post.php?post=772&action=edit">Agile Toolkit for CodeIgniter developer</a></div>
        <div><a href="http://agiletoolkit.org/blog/bundling-agile-toolkit-libraries-into-a-single-php-file/">Bundling Agile Toolkit Libraries into a single PHP file</a></div>
        <?rows?>
        <?row?><div><a href="<?url?><?/?>"><?name?>Introduction to Application Classes<?/?></a></div><?/?>
        <?/rows?>
        <?Model?>MoreInfo<?/?>
      </div>

    </div>

    <?add?>Suggest a Resource<?/?>

    <?/?>


  </div>
  <div class="g-6">
    <p>When you are developing your own application you typically would inherit one of Application Classes to make up your own Application object. By default it's located in lib/Frontend.php. This class is instantiated inside your top-most "index.php" file.</p>

    <p>In your Application Class you may define more functions which you think should be available from anywhere (such as getCurrentUser()) and perform actions, which you think should always be performed (Such as connecting to DataBase)</p>

    <?MoreInfo?>* Why API classes extend AbstractView?
    <p>You may wonder, why Application class designed for command-line use extends the View. Why application is based on view in the first place?</p>
    <p>The reason is because in descendants such as ApiFrontend it's essential that application would have it's own template and be capable of rendering itself. This could have been done through a separate object, but we decided to keep it simple and make it this way.</p>
    <?/?>

    <h4>Core Class Reference (PHPDoc)</h4>

    <div class="box blue-noised p-10px">
      <div class="white">
        <table>
          <thead>
            <tr>
              <th>Class</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a href="http://agiletoolkit.org/PhpDocumentor/docs-atk4/default/ApiCLI.html" class="dynamic">ApiCLI</a></td>
              <td>Minimum API Implementation for Command-Line</td>
            </tr>
            <tr>
              <td><a href="http://agiletoolkit.org/PhpDocumentor/docs-atk4/default/ApiCLI.html" class="dynamic">ApiWeb</a></td>
              <td>Minimum Web Application. Great for <a href="http://agiletoolkit.org/blog/integrating-agile-toolkit-with-wordpress/"
                  >integrating into other frameworks.</a></td>
            </tr>
            <tr>
              <td><a href="http://agiletoolkit.org/PhpDocumentor/docs-atk4/default/ApiFrontend.html" class="dynamic">ApiFrontend</a></td>
              <td>Extends Web App with Routing, Layouts and Page Classes</td>
            </tr>
          </tbody>
        </table>

      </div>
    </div>

  </div>
</div>
<?$Next?>
